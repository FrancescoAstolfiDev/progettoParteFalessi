<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 at 2025-06-01

 | Rendered using Apache Maven Default Skin
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="it" lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>My_Ispw2_Project_Falessi &#x2013; Risultati CPD</title>
    <link rel="stylesheet" href="./css/maven-base.css" />
    <link rel="stylesheet" href="./css/maven-theme.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
  </head>
  <body class="composite">
    <div id="banner">
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
      <div class="xleft">
        <span id="publishDate">Ultima Pubblicazione: 2025-06-01</span>
           | <span id="projectVersion">Versione: 1.0-SNAPSHOT</span>
      </div>
      <div class="xright">      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
      <a href="http://maven.apache.org/" title="Costruito da Maven" class="poweredBy">
        <img class="poweredBy" alt="Costruito da Maven" src="./images/logos/maven-feather.png" />
      </a>
      </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
<section>
<h2><a name="Risultati_CPD"></a>Risultati CPD</h2><a name="Risultati_CPD"></a>
<p>Il seguente documento contiene i risultati di PMD <a class="externalLink" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html">CPD</a> 6.55.0.</p><section>
<h3><a name="Duplicati"></a>Duplicati</h3><a name="Duplicati"></a>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\MetricsCalculator.java</td>
<td>415</td></tr>
<tr class="a">
<td align="left">project\controllers\MetricsCalculator1.java</td>
<td>435</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>File originalDir = new File(originalRepoPath);
        if (!originalDir.exists() &amp;&amp; !originalDir.mkdirs()) {
            throw new IOException(&quot;Impossibile ricreare la directory originale: &quot; + originalRepoPath);
        }

        // Copia tutti i file dal backup
        Path backupDir = Paths.get(backupRepoPath);
        Files.walk(backupDir)
                .forEach(source -&gt; {
                    try {
                        Path relativePath = backupDir.relativize(source);
                        Path destination = Paths.get(originalRepoPath, relativePath.toString());

                        // Se &#xe8; una directory, creala
                        if (Files.isDirectory(source)) {
                            if (!Files.exists(destination)) {
                                Files.createDirectories(destination);
                            }
                            return;
                        }

                        // Assicurati che la directory di destinazione esista
                        Files.createDirectories(destination.getParent());

                        // Copia il file
                        Files.copy(source, destination);
                    } catch (IOException e) {
                        System.err.println(&quot;Errore durante il ripristino del file: &quot; + source + &quot; - &quot; + e.getMessage());
                    }
                });

        // Riapri il repository
        git = Git.open(new File(originalRepoPath));
        repository = git.getRepository();

//        System.out.println(&quot;Ripristino del repository completato.&quot;);

        // Pulisci il backup
        deleteDirectory(new File(backupRepoPath));
    }


    /**
     * Crea una copia completa di backup del repository
     */
    private void backupRepository() throws IOException {
//        System.out.println(&quot;Creazione backup completo del repository in: &quot; + backupRepoPath);

        // Crea la directory di backup
        File backupDir = new File(backupRepoPath);
        if (!backupDir.exists() &amp;&amp; !backupDir.mkdirs()) {
            throw new IOException(&quot;Impossibile creare la directory di backup: &quot; + backupRepoPath);
        }

        // Copia tutti i file, inclusa l'intera directory .git
        Path sourceDir = Paths.get(originalRepoPath);
        Files.walk(sourceDir)
                .forEach(source -&gt; {
                    try {
                        Path relativePath = sourceDir.relativize(source);
                        Path destination = Paths.get(backupRepoPath, relativePath.toString());

                        // Se &#xe8; una directory, creala
                        if (Files.isDirectory(source)) {
                            if (!Files.exists(destination)) {
                                Files.createDirectories(destination);
                            }
                            return;
                        }

                        // Assicurati che la directory di destinazione esista
                        Files.createDirectories(destination.getParent());

                        // Copia il file
                        Files.copy(source, destination);
                    } catch (IOException e) {
//                        System.err.println(&quot;Errore durante il backup del file: &quot; + source + &quot; - &quot; + e.getMessage());
                    }
                });

//        System.out.println(&quot;Backup completo del repository completato.&quot;);
    }



    private long exportCodeToDirectory(RevCommit commit, Path targetDir) throws IOException {
        RevWalk revWalk = new RevWalk(repository);
        RevCommit parent = commit.getParentCount() &gt; 0 ? revWalk.parseCommit(commit.getParent(0).getId()) : null;

        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repository);
        df.setDiffComparator(RawTextComparator.DEFAULT);
        df.setDetectRenames(true);

        List&lt;DiffEntry&gt; diffs = df.scan(parent == null ? null : parent.getTree(), commit.getTree());
        boolean filesExported = false;

        for (DiffEntry entry : diffs) {
            if (entry.getChangeType() == DiffEntry.ChangeType.DELETE) continue; // Ignora file rimossi

            String path = entry.getNewPath();
            if (path.endsWith(&quot;.java&quot;) &amp;&amp; ! isTestFile(path)) {
                ObjectId objectId = commit.getTree().getId();

                try (TreeWalk treeWalk = TreeWalk.forPath(repository, path, commit.getTree())) {
                    if (treeWalk != null) {
                        byte[] content = repository.open(treeWalk.getObjectId(0)).getBytes();

                        Path targetFilePath = targetDir.resolve(path);
                        Files.createDirectories(targetFilePath.getParent());
                        Files.write(targetFilePath, content);
                        filesExported = true;
                    }
                }
            }
        }

        // Stampiamo quanti file sono stati effettivamente esportati
        // Verifichiamo prima che la directory esista

        long  count = 0;
        if (Files.exists(targetDir)) {
            count = Files.walk(targetDir)
                    .filter(p -&gt; p.toString().endsWith(&quot;.java&quot;))
                    .count();
//            System.out.println(&quot;File .java modificati esportati in &quot; + targetDir + &quot;: &quot; + count);
        } else {
//            System.out.println(&quot;Nessun file .java esportato in &quot; + targetDir);
        }
        return count;
    }

    private boolean isTestFile(String path) {
        String lowerPath = path.toLowerCase();
        return lowerPath.contains(&quot;/test/&quot;) || lowerPath.contains(&quot;test&quot;) || lowerPath.contains(&quot;mock&quot;);
    }


    private Map&lt;String, MethodInstance&gt; calculateCKMetrics(Path sourcePath) throws IOException {

        // Crea una mappa per contenere i risultati dei metodi analizzati


        Map&lt;String,MethodInstance&gt;methodInstanceResults=new HashMap&lt;&gt;();


        // Istanzia CK per l'analisi del codice
        CK ck = new CK();
        //final HashMap&lt;Object, Integer&gt; classFile_smell=(HashMap&lt;Object, Integer&gt;) PmdRunner.collectCodeSmellMetricsProject(sourcePath);;


        // Esegui l'analisi sui file sorgente specificati dal percorso
        ck.calculate(sourcePath, classResult -&gt; {
            if (classResult.getMethods() == null || classResult.getMethods().isEmpty()) {
                // Nessun metodo nella classe -&gt; ignora tranquillamente
                return;
            }
            // Itera su ciascun metodo trovato nella classe analizzata
            String pathClass=Release.normalizeToModuleAndClass(classResult.getClassName());

            int nSmell=-1;




            for (CKMethodResult method : classResult.getMethods()) {
                // Ottieni il nome completo del metodo (ad esempio: Classe.metodo)

                try {

                    nSmell=PmdRunner.collectCodeSmellMetricsClass(classResult.getClassName(),sourcePath.toString(),method.getStartLine(),method.getStartLine()+method.getLoc());



                    ClassFile filled_class=new ClassFile();
                    MethodInstance methodInstance= new MethodInstance();



                    methodInstance.setFilePath(method.getQualifiedMethodName());
                    methodInstance.setRelease(this.actRelease);
                    methodInstance.setClassName(classResult.getClassName());
                    methodInstance.setMethodName(method.getMethodName());
                    // methods added to class files for assigment of buggyness


                    methodInstance.setLoc(method.getLoc());
                    methodInstance.setWmc(method.getWmc());
                    methodInstance.setQtyAssigment(method.getAssignmentsQty());
                    methodInstance.setQtyMathOperations(method.getMathOperationsQty());
                    methodInstance.setQtyTryCatch(method.getTryCatchQty());
                    methodInstance.setQtyReturn(method.getReturnQty());
                    methodInstance.setFanin(method.getFanin());
                    methodInstance.setFanout(method.getFanout());


                    filled_class=actRelease.findClassFileByApproxName(classResult.getClassName());
                    if (filled_class!=null){
                        methodInstance.setAge(filled_class.getAge());
                        methodInstance.setnAuth(filled_class.getnAuth());
                        methodInstance.setNr(filled_class.getNR());
                        filled_class.addMethod(methodInstance);
                        methodInstance.setClassName(filled_class.getPath());
                    }else{
                        methodInstance.setAge(-1);
                        methodInstance.setnAuth(-1);
                    }

                    methodInstance.setnSmells(nSmell);
                    methodInstance.setBuggy(false);
                    methodInstanceResults.put(MethodInstance.createMethodKey(methodInstance),methodInstance);

                } catch (Exception e) {
//                    System.out.println(e);

                }
            }

        });

        // Restituisci tutti i risultati analizzati
        return methodInstanceResults;
    }

    /**
     * Fill the last class files list
     */
    private void lastClassesEvaluation(Path sourcePath)  {


        Map&lt;String,ClassFile&gt; innerResults=new HashMap&lt;&gt;();

        // Istanzia CK per l'analisi del codice
        CK ck = new CK();
        // Esegui l'analisi sui file sorgente specificati dal percorso
        ck.calculate(sourcePath, classResult -&gt; {
            if (classResult.getMethods() == null || classResult.getMethods().isEmpty()) {
                // Nessun metodo nella classe -&gt; ignora tranquillamente
                return;
            }


            ClassFile filled_class=new ClassFile();
            filled_class=actRelease.findClassFileByApproxName(classResult.getClassName());
            if (! innerResults.containsKey(filled_class.getPath())){
                ClassFile actClass;
                actClass=filled_class;
                innerResults.put(actClass.getPath(),actClass);
                addLastClassFiles(innerResults);
            }





        });



    }



    private void addLastClassFiles(Map&lt;String,ClassFile&gt; lastResults){
        if (resultsInstances.size() &gt;= sizeWindow) {
            resultsInstances.removeFirst();
        }
        resultsInstances.addLast(lastResults);

        lastClassFiles.clear();
        for (Map&lt;String, ClassFile&gt; map : resultsInstances) {
            lastClassFiles.putAll(map);
        }
    }




    List&lt;ClassFile&gt; buggyClasses = new ArrayList&lt;&gt;();
    //questo metodo scorre le release e assegna il valore buggyness delle classi
    private void assignBuggyness(){

        List&lt;RevCommit&gt; revCommitList = new ArrayList&lt;&gt;();
        for(Ticket ticket:releaseTickets){
//            System.out.println(&quot;Assegnando buggyness al ticket &quot; + ticket.getKey());
            List&lt;RevCommit&gt; ticketCommits = ticket.getAssociatedCommits();
            for (RevCommit commit : ticketCommits) {
//                System.out.println(&quot;Assegnando buggyness al commit &quot; + commit.getName());
                revCommitList.add(commit);
            }

        }
        sortCommits(revCommitList);

        int len = revCommitList.size();
        for (int i = 1; i &lt; len; i++){
            RevCommit commit = revCommitList.get(i);
            List&lt;String&gt; modifiedClasses = gitHubInfoRetrieve.getDifference(commit,false);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\MetricsCalculator.java</td>
<td>192</td></tr>
<tr class="a">
<td align="left">project\controllers\MetricsCalculator1.java</td>
<td>189</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>System.err.println(&quot;Errore durante l'assegnazione dei buggyness: &quot; + e.getMessage());
        return new HashMap&lt;&gt;();
    }
    }
    // Metodo di supporto per pulire le directory temporanee
    private void cleanupTempDirectory(Path dirPath) {
        try {
            if (Files.exists(dirPath)) {
                Files.walk(dirPath)
                        .sorted(Comparator.reverseOrder())
                        .map(Path::toFile)
                        .forEach(File::delete);
            }
        } catch (IOException e) {
            System.err.println(&quot;Impossibile pulire la directory temporanea &quot; + dirPath + &quot;: &quot; + e.getMessage());
        }
    }
    private File ensureTempDirectoryExists(Path path) {
        try {
            Files.createDirectories(path);
            File dir = path.toFile();
            return dir;
        } catch (IOException e) {
            throw new RuntimeException(&quot;Impossibile creare la directory temporanea: &quot; + path, e);
        }
    }




    public void calculateAll(List&lt;Release&gt; releaseList) throws IOException {
        RevCommit veryFirstCommit = null;

        int len = releaseList.size();
        for(int i = 0; i &lt; len; i++){
            Release currRelease = releaseList.get(i);

            List&lt;ClassFile&gt; classFiles = currRelease.getReleaseAllClass();

            List&lt;RevCommit&gt; revCommitList = currRelease.getAllReleaseCommits();
            RevCommit firstCommit = revCommitList.get(0);

            for(RevCommit commit:revCommitList){
                if(veryFirstCommit == null){
                    veryFirstCommit = commit;
                }

                List&lt;String&gt; modifiedFiles = gitHubInfoRetrieve.getDifference(commit,false);
                List&lt;String&gt; addedFiles = gitHubInfoRetrieve.getDifference(commit,true);
                String authorName = commit.getAuthorIdent().getName();
                if(!modifiedFiles.isEmpty() &amp;&amp; i == 0) {
                    updateNr(modifiedFiles, currRelease);
                    calculateDateOfCreation(currRelease,currRelease,commit.getCommitterIdent().getWhen(),addedFiles);
                }
                else if(!modifiedFiles.isEmpty()){
                    updateNr(modifiedFiles, currRelease);
                    calculateDateOfCreation(currRelease,releaseList.get(i-1),commit.getCommitterIdent().getWhen(),addedFiles);
                }
                updateNAuth(modifiedFiles,currRelease,authorName);
            }

            creationDateSetter(classFiles,firstCommit);



        }
        calculateAge(releaseList);



    }

    private void calculateAge(List&lt;Release&gt; releaseList){
        int len = releaseList.size();
        for(int i = 0; i &lt; len; i++){
            Release currRelease = releaseList.get(i);
            List&lt;ClassFile&gt; allReleaseFiles = currRelease.getReleaseAllClass();
            if(i == 0){
                for(ClassFile file: allReleaseFiles){
                    int age = (int) ((currRelease.getDate().getTime() - file.getCreationDate().getTime()) / 86400000);
                    file.setAge(age);
                }
                continue;
            }
            Release precRelease = releaseList.get(i-1);
            for(ClassFile file:allReleaseFiles){
                ClassFile preFile;
                try{
                    preFile = precRelease.getClassFileByPath(file.getPath());
                    int age = (int) ((file.getCreationDate().getTime() - preFile.getCreationDate().getTime()) /86400000);
                    age = age + preFile.getAge();
                    file.setAge(age);
                }
                catch(Exception e){
                    int age = (int) ((currRelease.getDate().getTime() - file.getCreationDate().getTime()) / 86400000);
                    file.setAge(age);
                }
            }
        }
    }


    private void creationDateSetter(List&lt;ClassFile&gt; classFiles,RevCommit firstCommit){
        for (ClassFile file : classFiles) {
            if (file.getCreationDate() == null) {
                file.setCreationDate(firstCommit.getCommitterIdent().getWhen());
            }
        }
    }

    private void updateNAuth(List&lt;String&gt; modifiedFiles,Release release,String authName){
        for(String path:modifiedFiles){
            ClassFile file = release.getClassFileByPath(path);
            if (file != null){
                file.addAuthor(authName);
            }
        }
    }
    private void updateNr(List&lt;String&gt; modifiedFiles,Release release){
        for(String path:modifiedFiles){
            ClassFile file = release.getClassFileByPath(path);
            if(file != null){
                file.incrementNR();
            }
        }
    }

    private void calculateDateOfCreation(Release currentRelease, Release precRelease, Date commitDate, List&lt;String&gt; addedFiles){
        if(currentRelease.getId() == precRelease.getId()){
            for(String file:addedFiles){
                ClassFile currFile = currentRelease.getClassFileByPath(file);
                if(currFile != null &amp;&amp; (currFile.getCreationDate() == null || currFile.getCreationDate().after(commitDate))){
                    currFile.setCreationDate(commitDate);
                }
            }
            return;
        }
        parserFiles(addedFiles,precRelease,currentRelease,commitDate);
    }

    private void parserFiles(List&lt;String&gt; addedFiles,Release precRelease,Release currentRelease,Date commitDate){
        for(String file:addedFiles){
            ClassFile precFile = precRelease.getClassFileByPath(file);
            //precFile == null se nella release precedente era presente la classe java in questione
            if(precFile == null){
                ClassFile currFile = currentRelease.getClassFileByPath(file);
                if(currFile != null &amp;&amp; currFile.getCreationDate() != null){
                    if(commitDate.before(currFile.getCreationDate())){
                        currFile.setCreationDate(commitDate);
                    }
                }
                else if(currFile != null){
                    currFile.setCreationDate(commitDate);
                }
            }
            //qui la classe java &#xe8; stata introdotta nella pi&#xf9; recente release
            else if(currentRelease.getClassFileByPath(file) != null){
                currentRelease.getClassFileByPath(file).setCreationDate(commitDate);
            }
        }
    }


    private List&lt;RevCommit&gt; filterCommitsByRelease(List&lt;RevCommit&gt; commits, Release release) {
        // Implementazione che filtra i commit in base alla data della release
        List&lt;RevCommit&gt; filteredCommits = new ArrayList&lt;&gt;();
        for (RevCommit commit : commits) {
            if (commit.getAuthorIdent().getWhen().before(release.getDate())) {
                filteredCommits.add(commit);
            }
        }
        return filteredCommits;
    }



    private void checkoutRelease(RevCommit commit) throws GitAPIException, IOException {
        String targetCommit = commit.getId().getName();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\MetricsCalculator.java</td>
<td>712</td></tr>
<tr class="a">
<td align="left">project\controllers\MetricsCalculator1.java</td>
<td>733</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>List&lt;String&gt; modifiedClasses = gitHubInfoRetrieve.getDifference(commit,false);

            for (String className : modifiedClasses) {
                System.out.println(&quot; - &quot; + className);
            }

            if (!modifiedClasses.isEmpty()) {
                updateBuggyness(modifiedClasses);
            }

        }
        System.out.println(&quot;Fine assegnazione buggyness alle classi&quot;);
        System.out.println(&quot;Classi bugginese: &quot;+buggyClasses.size());
//        for(ClassFile file: buggyClasses){
//            System.out.println(file.getPath());
//        }
    }

    //questo metodo scorre tutti i file modificati da un commit correlato ad un ticket, quindi tali classi
    //si assumono buggy e quindi deve essere settato il parametro buggy a true
    private void updateBuggyness(List&lt;String&gt; allPaths) {
//        System.out.println(&quot;Classi da modificare: &quot; + allPaths.sizeWindow());

        for (String path : allPaths) {
            //ClassFile currentFile = lastClassFiles.get(path);
            ClassFile currentFile = actRelease.getClassFileByPath(path);

            if (currentFile == null) continue;
            buggyClasses.add(currentFile);
            String oldContent = gitHubInfoRetrieve.getFileContentBefore(path); // da implementare
            String newContent = gitHubInfoRetrieve.getFileContentNow(path);    // da implementare

            Map&lt;String, String&gt; oldMethods = extractMethodBodiesByName(oldContent); // nome &#x2192; corpo
            Map&lt;String, String&gt; newMethods = extractMethodBodiesByName(newContent);

            for (MethodInstance method : currentFile.getMethods()) {
                String name = ckSignature(method.getMethodName());

                if (!oldMethods.containsKey(name) || !newMethods.containsKey(name)) {
                    // Metodo aggiunto o rimosso &#x2192; potenzialmente buggy
                    method.setBuggy(true);
                    continue;
                }

                String oldBody = oldMethods.get(name);
                String newBody = newMethods.get(name);

                if (!oldBody.equals(newBody)) {
                    method.setBuggy(true);
                }
            }

            buggyClasses.add(currentFile);
        }
    }
    private static List&lt;String&gt; extractMethodSignatures(String javaSource) {
        try {
            CompilationUnit cu = StaticJavaParser.parse(javaSource);
            return cu.findAll(MethodDeclaration.class).stream()
                    .map(m -&gt; m.getSignature().toString())
                    .toList();
        } catch (Exception e) {
            e.printStackTrace();
            return List.of();
        }

    }
    private static Map&lt;String, String&gt; extractMethodBodiesByName(String source) {
        Map&lt;String, String&gt; methodMap = new HashMap&lt;&gt;();

        if (source == null || source.trim().isEmpty()) {
//            System.out.println(&quot;Sorgente vuota o nulla, impossibile estrarre i metodi&quot;);
            return methodMap;
        }

        // Optional: se il contenuto sembra troppo corto o non valido, evita il parsing
//        if (!source.contains(&quot;class&quot;) &amp;&amp; !source.contains(&quot;interface&quot;) &amp;&amp; !source.contains(&quot;enum&quot;)) {
//            System.out.println(&quot;Il contenuto non sembra un file Java completo, salto il parsing.&quot;);
//            return methodMap;
//        }

        try {
            CompilationUnit cu = StaticJavaParser.parse(source);

            cu.findAll(MethodDeclaration.class).forEach(m -&gt; {
                String name = m.getNameAsString();
                String body = m.getBody().map(Object::toString).orElse(&quot;&quot;);
                methodMap.put(name, body);
            });
        } catch (ParseProblemException e) {
            System.out.println(&quot;Errore di parsing del codice sorgente: &quot; + e.getMessage());
            System.out.println(&quot;Il codice sorgente contiene sintassi Java non valida e verr&#xe0; ignorato&quot;);
            try {
                String errorFilePath = System.getProperty(&quot;java.io.tmpdir&quot;) + &quot;/parsing_error_&quot; +
                        System.currentTimeMillis() + &quot;.txt&quot;;
                Files.writeString(Paths.get(errorFilePath), source);
//                System.out.println(&quot;Codice problematico salvato in: &quot; + errorFilePath);
            } catch (IOException ioe) {
                // Ignora errori durante il salvataggio
            }
        } catch (Exception e) {
           System.out.println(&quot;Errore durante l'estrazione dei metodi: &quot; + e.getClass().getName());
           System.out.println(&quot;Messaggio: &quot; + e.getMessage());
        }

        return methodMap;
    }



    //un metodo utile per ordinare i commit in ordine temporale
    private void sortCommits(List&lt;RevCommit&gt; commits){

        Collections.sort(commits,new RevCommitComparator());
    }

    //il comparator utile a sortCommits
    private class RevCommitComparator implements Comparator&lt;RevCommit&gt; {
        @Override
        public int compare(RevCommit a, RevCommit b) {
            return a.getCommitterIdent().getWhen().compareTo(b.getCommitterIdent().getWhen());
        }
    }




















}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\MetricsCalculator.java</td>
<td>77</td></tr>
<tr class="a">
<td align="left">project\controllers\MetricsCalculator1.java</td>
<td>75</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>List&lt;RevCommit&gt;releaseCommits = commits.subList(0, passingList.size());
        System.out.println((&quot; \n\n inizio calcolo metriche per la release &quot; + release.getName()));

        this.actRelease = release;
        this.releaseTickets = releaseTickets;

        File gitDir = repository.getDirectory();
        originalRepoPath = gitDir.getParentFile().getAbsolutePath();
        // Crea un percorso per il backup
        backupRepoPath = originalRepoPath + &quot;_backup_&quot; + System.currentTimeMillis();
        backupRepository();

        // Numero ottimale di thread basato sui core disponibili
        int numThreads = Math.min(Runtime.getRuntime().availableProcessors(), 6);
        System.out.println(&quot;Numero di thread: &quot; + numThreads);
        ForkJoinPool customThreadPool = new ForkJoinPool(numThreads);
        System.out.println(&quot;number of commit to check&quot; + releaseCommits.size());
        Map&lt;String, RevCommit&gt; commits_analized = new HashMap&lt;&gt;();
        try {
            // Crea un lock per sincronizzare l'accesso al repository
            Object repoLock = new Object();

            // Separa l'ultimo commit per elaborazione sequenziale
            AtomicInteger countThread = new AtomicInteger();
            // Elabora i commit in parallelo (escluso l'ultimo)
            sortCommits(releaseCommits);

            customThreadPool.submit(() -&gt;
                releaseCommits.parallelStream().forEach(commit -&gt; {
                    // Directory unica per ogni commit usando l'hash del commit
                    String commitHash = commit.getId().getName();
                    if (resultCommitsMethods.containsKey(commit)) {
                        Map&lt;String, MethodInstance&gt; commitMetrics = resultCommitsMethods.get(commit);
                        // Aggiorna i risultati in modo thread-safe
                        releaseResults.putAll(commitMetrics);
                        commits_analized.put(commitHash, commit);
                    } else {
                        Path commitTempDir = tempDirPath.resolve(release.getName() + &quot;_&quot; + commitHash);
                        commits_analized.put(commitHash, commit);
                        try {

                            // Sincronizza l'accesso al repository Git
                            synchronized (repoLock) {
                                // Checkout del commit appartenente alla release
                                checkoutRelease(commit);
                                ensureTempDirectoryExists(commitTempDir);
                                exportCodeToDirectory(commit, commitTempDir);

                            }

                            // Il calcolo delle metriche CK pu&#xf2; avvenire in parallelo
                            // (senza bisogno di sincronizzazione)
                            countThread.getAndIncrement();
                            int log = countThread.get();
                            if ((log % 2) == 0) {
                                System.out.println(&quot;Thread &quot; + countThread.get() + &quot; in corso...&quot; + &quot;analyzing commit &quot; + commit.getId() + &quot; ...&quot; + &quot;commit analyzed&quot; + commits_analized.size());
                            }

                            Map&lt;String, MethodInstance&gt; commitMetrics = calculateCKMetrics(commitTempDir);
                            resultCommitsMethods.put(commit, commitMetrics);
                            // Aggiorna i risultati in modo thread-safe
                            releaseResults.putAll(commitMetrics);

                            // Pulisci la directory temporanea del commit
                            cleanupTempDirectory(commitTempDir);

                        } catch (Exception e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\MetricsCalculator.java</td>
<td>153</td></tr>
<tr class="a">
<td align="left">project\controllers\MetricsCalculator1.java</td>
<td>151</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>if (!releaseCommits.isEmpty() &amp;&amp; releaseTickets.size() &gt; 0) {
                int lastIndex=releaseCommits.size() ;
                while(lastClassFiles.size()&lt;this.sizeWindow){
                    long modified = 0;
                    Path commitTempDir = null;
                    String commitHash = &quot;&quot;;
                    while (modified == 0 &amp;&amp; lastIndex&gt;0) {
                        lastIndex--;
                        RevCommit commit = releaseCommits.get(lastIndex);
                        commitHash = commit.getId().getName();
                        commitTempDir = tempDirPath.resolve(release.getName() + &quot;_&quot; + commitHash);
                        checkoutRelease(commit);
                        ensureTempDirectoryExists(commitTempDir);
                        modified = exportCodeToDirectory(commit, commitTempDir);

                    }
                    lastClassesEvaluation(commitTempDir);
                    cleanupTempDirectory(commitTempDir);
                }


            }

        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(&quot;Errore durante l'elaborazione parallela&quot;, e);
        } finally {
            customThreadPool.shutdown();
        }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\GitHubInfoRetrieve.java</td>
<td>65</td></tr>
<tr class="a">
<td align="left">project\controllers\GitHubInfoRetrieve.java</td>
<td>224</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>public void getMethodInstancesOfCommit(Release release) throws IOException {
        TreeWalk treeWalk = new TreeWalk(repo);
        RevCommit commit = release.getLastCommitPreRelease();
        RevTree tree = commit.getTree();
        treeWalk.addTree(tree);
        treeWalk.setRecursive(true);

        while (treeWalk.next()) {
            String filePath = treeWalk.getPathString();

            if (filePath.contains(SUFFIX) &amp;&amp; !filePath.contains(PREFIX)) {
                ObjectId objectId = treeWalk.getObjectId(0);
                ObjectLoader loader = null;
                try {
                    loader = repo.open(objectId);
                } catch (MissingObjectException e) {
                    continue;
                }
                byte[] fileContentBytes = loader.getBytes();
                String fileContent = new String(fileContentBytes);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Linea</th></tr>
<tr class="b">
<td align="left">project\controllers\MetricsCalculator.java</td>
<td>61</td></tr>
<tr class="a">
<td align="left">project\controllers\MetricsCalculator1.java</td>
<td>59</td></tr>
<tr class="b">
<td colspan="2" align="left">
<div class="source">
<pre>public MetricsCalculator(GitHubInfoRetrieve gitHubInfoRetrieve) throws IOException {
        File repoDir = new File(gitHubInfoRetrieve.getPath());
        this.repository = Git.open(repoDir).getRepository();
        this.git = new Git(repository);
        this.gitHubInfoRetrieve=gitHubInfoRetrieve;
        Files.createDirectories(Paths.get(String.valueOf(tempDirPath)));

    }
    public Map&lt;String, MethodInstance&gt; calculateReleaseMetrics(List&lt;RevCommit&gt; commits, Release release, List&lt;Ticket&gt; releaseTickets) throws IOException, GitAPIException {
        // Utilizziamo ConcurrentHashMap per la thread-safety
        try{


        ConcurrentMap&lt;String, MethodInstance&gt; releaseResults = new ConcurrentHashMap&lt;&gt;();
        List&lt;RevCommit&gt; passingList = filterCommitsByRelease(commits, release);</pre></div></td></tr></table></section></section>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
        Copyright &#169;      2025..      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
